/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           |
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    OpenFOAM is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM; if not, write to the Free Software Foundation,
    Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

Description
    Reads all sections of a .msh file.

\*---------------------------------------------------------------------------*/

#include "IFstream.H"
#include "cellModeller.H"

#include "gmshMesh.H"
#include "gmshMessageStream.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

gmshMesh::gmshMesh(const label verbosity):
    gmshMeshFormat(verbosity),
    gmshPhysicalNames(verbosity),
    gmshNodes(verbosity),
    gmshElements(mshToFoam(), verbosity),
    verbosity_(verbosity)
{
}

gmshMesh::gmshMesh(const fileName& mshName, const word& execName,
const label verbosity):
    gmshMeshFormat(verbosity),
    gmshPhysicalNames(verbosity),
    gmshNodes(verbosity),
    gmshElements(mshToFoam(), verbosity),
    verbosity_(verbosity)
{
    // Input stream of the .msh file
    IFstream inFile(mshName);

    if(inFile.bad())
    {
        FatalErrorIn(execName)
            << "Can't open " << mshName << "." << exit(FatalError);
    }

    readSections(inFile, execName);
}

// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

void gmshMesh::readSections(IFstream& inFile, const word& execName)
{
    for(word tag(inFile); !inFile.eof(); inFile >> tag)
    {
        // tags suffixed by a '\r' are for compatibility with .msh
        // files generated by Windows versions of Gmsh
        if (tag == "$NOD" || tag == "$NOD\r")
        {
            gInfo(verbosity_ >= 4) << "File format version: 1.0" << endl
                << endl;
            formatVersion() = 1.0;

            readNodes(inFile, formatVersion(), execName);
        }
        else if (tag == "$MeshFormat" || tag == "$MeshFormat\r")
        {
            readMeshFormat(inFile, execName);
        }
	else if(formatVersion() == 2.0
        && (tag == "$PhysicalNames" || tag == "$PhysicalNames\r"))
        {
            readPhysicalNames(inFile, execName);
        }
	else if(formatVersion() == 2.0
        && (tag == "$Nodes" || tag == "$Nodes\r"))
        {
            readNodes(inFile, formatVersion(), execName);
        }
        else if ((formatVersion() == 1.0 && (tag == "$ELM" || tag == "$ELM\r"))
        || (formatVersion() == 2.0
        && (tag == "$Elements" || tag == "$Elements\r")))
        {
            readElements(inFile, mshToFoam(), physicalNames().size() > 0,
            formatVersion(), execName);
        }
        else
        {
            FatalErrorIn(execName)
                << "Unknown section name " << tag << " on line "
                    << inFile.lineNumber() << exit(FatalError);
        }
    }
}

// Determine whether cell is inside-out by checking for any wrong-oriented
// face.
bool gmshMesh::correctOrientation(const pointField& points,
const cellShape& shape) const
{
    // Get centre of shape.
    point cc(shape.centre(points));

    // Get outwards pointing faces.
    faceList faces(shape.faces());

    forAll(faces, i)
    {
        const face& f = faces[i];

        vector n(f.normal(points));

        // Check if vector from any point on face to cc points outwards
        if (((points[f[0]] - cc) & n) < 0)
        {
            // Incorrectly oriented
            return false;
        }
    }

    return true;
}

void gmshMesh::doAutoInvert()
{
    gInfo(verbosity_ >= 1)
        << endl << "Automatically inverting cells with wrong orientation"
            << (verbosity_ >= 4 ? ":" : "") << endl;

    forAll(cells(), cellI)
    {
        cellShape& cell = cells()[cellI];

        // Determining the cell type by the number of vertices, not by
        // the elmType entry in the .msh file. Currently it's OK
        // because there are no duplicate numbers of vertices in
        // first-order cells, but this might cause problems in the
        // future.
        if(cell.size() == 6) // prism
        {
            if (!correctOrientation(points(), cell))
            {
                gInfo(verbosity_ >= 4) << "Inverting prism " << cellI << endl;

                labelList cellPoints(6);
                // Reorder prism.
                cellPoints[0] = cell[0];
                cellPoints[1] = cell[2];
                cellPoints[2] = cell[1];
                cellPoints[3] = cell[3];
                cellPoints[4] = cell[4];
                cellPoints[5] = cell[5];

                cell = cellShape(cell.model(), cellPoints);
            }
        }
        else if(cell.size() == 8) // hex
        {
            if (!correctOrientation(points(), cell))
            {
                gInfo(verbosity_ >= 4) << "Inverting hex " << cellI << endl;

                labelList cellPoints(8);
                // Reorder hex.
                cellPoints[0] = cell[4];
                cellPoints[1] = cell[5];
                cellPoints[2] = cell[6];
                cellPoints[3] = cell[7];
                cellPoints[4] = cell[0];
                cellPoints[5] = cell[1];
                cellPoints[6] = cell[2];
                cellPoints[7] = cell[3];

                cell = cellShape(cell.model(), cellPoints);
            }
        }
    }
    gInfo(verbosity_ >= 4) << "    ... automatic inversion done." << endl;
}

void gmshMesh::doUnusedPointRemoval()
{
    gInfo(verbosity_ >= 1) << endl << "Removing unused points"
        << (verbosity_ >= 4 ? ":" : "") << endl;

    boolList usedPoints(points().size(), false);

    // Determine unused points
    forAll(patchFaces(), patchI)
    {
        forAll(patchFaces()[patchI], faceI)
        {
            forAll(patchFaces()[patchI][faceI], vertexI)
            {
                usedPoints[patchFaces()[patchI][faceI][vertexI]] = true;
            }
        }
    }
    forAll(cells(), cellI)
    {
        forAll(cells()[cellI], vertexI)
        {
            usedPoints[cells()[cellI][vertexI]] = true;
        }
    }
    

    // Remove unused points. The algorithm is so inefficient that it
    // might require further improvements.
    label nRemovedPoints = 0;
    for(label pointI = usedPoints.size() - 1; pointI >= 0; pointI--)
    {
        if(usedPoints[pointI] == false)
	{
            for(label pointJ = pointI; pointJ < points().size() - 1; pointJ++)
	    {
                points()[pointJ] = points()[pointJ + 1];
	    }
            points().setSize(points().size() - 1);

            forAll(patchFaces(), patchI)
	    {
                forAll(patchFaces()[patchI], faceI)
		{
                    forAll(patchFaces()[patchI][faceI], vertexI)
		    {
                        if(patchFaces()[patchI][faceI][vertexI] > pointI)
			{
                            patchFaces()[patchI][faceI][vertexI]--;
			}
		    }
		}
	    }
            forAll(cells(), cellI)
	    {
                forAll(cells()[cellI], vertexI)
		{
                    if(cells()[cellI][vertexI] > pointI)
		    {
                        cells()[cellI][vertexI]--;
		    }
		}
	    }
            nRemovedPoints++;
            if(verbosity_ >= 5 && (nRemovedPoints % 100) == 0)
            {
                gInfo << "    Removed " << nRemovedPoints << " points" << endl;
            }
	}
    }

    if(nRemovedPoints > 0)
    {
        // If there are removed points the mshToFoam mapper no longer works.
        mshToFoam().clear();
    }

    gInfo(verbosity_ >= 4) << "    ... removed " << nRemovedPoints
        << " points." << endl;
}

void gmshMesh::patchAndZoneNames(wordList& boundaryPatchNames,
wordList& boundaryPatchTypes, wordList& cellZoneNames)
{
    boundaryPatchNames.setSize(patchFaces().size());
    boundaryPatchTypes.setSize(patchFaces().size());

    // Base patch types default to "patch"
    forAll(boundaryPatchTypes, patchI)
    {
        boundaryPatchTypes[patchI] = polyPatch::typeName;
    }

    // Split the physicalNames into two words: the first word the name
    // of the patch, the second word (if present) the base patch type
    forAll(physicalNumbers(), numberI)
    {
        Map<label>::iterator regFnd
            = regionToPatch().find(physicalNumbers()[numberI]);
        if(regFnd != regionToPatch().end())
        {
            string::size_type pos
                = physicalNames()[numberI].find_first_of(" \t");
            if(pos == string::npos)
            {
                boundaryPatchNames[regFnd()]
                    = word(physicalNames()[numberI]);
            }
            else
            {
                // physicalNames[numberI] containes whitespaces
                boundaryPatchNames[regFnd()]
                    = word(physicalNames()[numberI].substr(0, pos));

                // skip whitespaces
                pos = physicalNames()[numberI].find_first_not_of(" \t", pos);
                if(pos != string::npos)
                {
                    // use the second word of physicalNames[numberI]
                    // as base patch type
                    boundaryPatchTypes[regFnd()]
                        = word(physicalNames()[numberI].substr(pos));
                }
            }
        }
    }

    forAll(boundaryPatchNames, patchI)
    {
        if(!boundaryPatchNames[patchI].length())
	{
            boundaryPatchNames[patchI] = word("patch")
                + name(patchToRegion()[patchI]);
	}
    }

    if(verbosity_ >= 5)
    {
        // Print tentative patches/faceZones
        label maxLen = 0;
        forAll(patchFaces(), patchI)
            {
                label len = boundaryPatchNames[patchI].length();
                if (len > maxLen)
                {
                    maxLen = len;
                }
            }

        gInfo << nl << "Tentative patches/FaceZones:" << nl
            << "Patch\tSize\tName";
        for(label i = 0; i < maxLen - 4; i++)
        {
            gInfo << ' ';
        }
        gInfo << "\tBase type" << endl;

        forAll(patchFaces(), patchI)
        {
            label len = boundaryPatchNames[patchI].length();
            gInfo << "    " << patchI << '\t' << patchFaces()[patchI].size()
                << '\t' << boundaryPatchNames[patchI];
            for(label i = 0; i < maxLen - len; i++)
            {
                gInfo << ' ';
            }
            gInfo << '\t' << boundaryPatchTypes[patchI] << endl;
        }
    }

    // Determine names of cellZones. faceZones will be named later in
    // polyMeshConversion::constructzones()
    cellZoneNames.setSize(zoneCells().size());

    forAll(physicalNumbers(), numberI)
    {
        Map<label>::iterator regFnd
            = regionToZone().find(physicalNumbers()[numberI]);
        if(regFnd != regionToZone().end())
        {
            cellZoneNames[regFnd()] = word(physicalNames()[numberI]);
        }
    }

    forAll(zoneCells(), zoneI)
    {
        const labelList& zCells = zoneCells()[zoneI];

        if (zCells.size() > 0)
        {
	    if(!cellZoneNames[zoneI].length())
            {
		cellZoneNames[zoneI] = "cellZone_"
                    + name(zoneToRegion()[zoneI]);
            }

        }
    }
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// ************************************************************************* //
